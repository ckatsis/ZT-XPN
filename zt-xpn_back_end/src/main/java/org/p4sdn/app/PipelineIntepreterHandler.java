package org.p4sdn.app;

import static java.lang.String.format;
import static org.onlab.util.ImmutableByteSequence.copyFrom;
import static org.onosproject.net.PortNumber.CONTROLLER;
import static org.onosproject.net.PortNumber.FLOOD;
import static org.onosproject.net.flow.instructions.Instruction.Type.OUTPUT;
import static org.onosproject.net.pi.model.PiPacketOperationType.PACKET_OUT;

import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.onlab.packet.DeserializationException;
import org.onlab.packet.Ethernet;
import org.onlab.util.ImmutableByteSequence;
import org.onosproject.net.ConnectPoint;
import org.onosproject.net.DeviceId;
import org.onosproject.net.Port;
import org.onosproject.net.PortNumber;
import org.onosproject.net.device.DeviceService;
import org.onosproject.net.driver.AbstractHandlerBehaviour;
import org.onosproject.net.flow.TrafficTreatment;
import org.onosproject.net.flow.criteria.Criterion;
import org.onosproject.net.flow.criteria.Criterion.Type;
import org.onosproject.net.flow.instructions.Instruction;
import org.onosproject.net.flow.instructions.Instructions.OutputInstruction;
import org.onosproject.net.packet.DefaultInboundPacket;
import org.onosproject.net.packet.InboundPacket;
import org.onosproject.net.packet.OutboundPacket;
import org.onosproject.net.pi.model.PiActionId;
import org.onosproject.net.pi.model.PiActionParamId;
import org.onosproject.net.pi.model.PiMatchFieldId;
import org.onosproject.net.pi.model.PiPacketMetadataId;
import org.onosproject.net.pi.model.PiPipelineInterpreter;
import org.onosproject.net.pi.model.PiTableId;
import org.onosproject.net.pi.runtime.PiAction;
import org.onosproject.net.pi.runtime.PiAction.Builder;
import org.onosproject.net.pi.runtime.PiActionParam;
import org.onosproject.net.pi.runtime.PiPacketMetadata;
import org.onosproject.net.pi.runtime.PiPacketOperation;
import org.p4sdn.app.flow.DependencyStateIdInstruction;
import org.p4sdn.app.flow.ExtendedInstruction;
import org.p4sdn.app.flow.StateIdInstruction;
import org.p4sdn.app.flow.StatefulProcessingInstruction;
import org.p4sdn.app.net.Protocol;
import org.p4sdn.app.pipeline.BMV2Pipeline;
import org.p4sdn.app.pipeline.components.Action;
import org.p4sdn.app.pipeline.components.ControllerHeader;
import org.p4sdn.app.pipeline.components.NoAction;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import org.p4sdn.app.pipeline.Pipeline;
import org.p4sdn.app.pipeline.components.Control;
import org.p4sdn.app.pipeline.components.Table;
import org.slf4j.Logger;



public final class PipelineIntepreterHandler 
            extends AbstractHandlerBehaviour
            implements PiPipelineInterpreter {

    private static Map<Criterion.Type, PiMatchFieldId> criterionToPiMatchFieldMap = new HashMap<>();
    public static Map<Integer, PiTableId> tableMap = new HashMap<>();
    private static PiActionId noActionId = null;
    private static PiActionId setOutPortAction = null;
    private static PiActionId sendToControllerAction = null;
    public static PiActionId packetStatefulProcessing = null;
    public static PiActionParamId outPortParam = null; // PiActionParamId.of("port");
    // Params for stateful packet action handling
    // bit<1> isStatefulFlow_param, bit<32> state_index_param, bit<1> isDependentFlow_param, bit<32> dependency_state_index_param, bit<9> out_port
    public static PiActionParamId isStatefulParam = null;
    public static PiActionParamId stateIndexParam = null;
    public static PiActionParamId isDependentFlowParam = null;
    public static PiActionParamId dependencyStateIndexParam = null;
    private static PiPacketMetadataId pcktOutEgress = null;

    private static Logger log;


    /***
     * We develop the criterion map as per the generated matching fields of the pipeline
     * @param matchFields The matching fields generated by the compilation process
     */
    public static void initACL(Pipeline pipeline, Logger l) {
    // , List<String> matchFields, String defaultTableFullName, 
    //                         boolean isNoAction, Action fwdAction, Action fwdControllerAction) {
        log = l;
        Table acTable = pipeline.getControlBlockByName(BMV2Pipeline.INGRESS_CONTROL_NAME).getTable(Control.ACL_TABLE_NAME);
        
        if (acTable == null)
            return;

        List<String> matchFields = acTable.getKeyEntriesAsStringList();

        for(String mf: matchFields) {
            // log.info("Match Field: " + mf);
            if(mf.startsWith(BMV2Pipeline.STD_META_EGRESS_INGRESS_PORT_NAME)) {
                criterionToPiMatchFieldMap.put(Criterion.Type.IN_PORT, 
                                    PiMatchFieldId.of(BMV2Pipeline.STD_META_EGRESS_INGRESS_PORT_NAME));
            } else {
                Pattern pattern = Pattern.compile(BMV2Pipeline.PARSED_HEADERS_NAME + "\\.(\\w+)\\.(\\w+)");
                Matcher matcher = pattern.matcher(mf);

                if(matcher.find()) {
                    Criterion.Type type =  Protocol.getCriterionType(matcher.group(1),  matcher.group(2));

                    if(type != null) {
                        // log.info("Type found: " + type);
                        criterionToPiMatchFieldMap.put(type, PiMatchFieldId.of(mf));
                    }
                }
            }
        }
        // int i = 0;

        // log.info("Step i= " + i);
        // i++;
        if(tableMap.get(0) == null){
            tableMap.put(0, PiTableId.of(acTable.getFullyQualifiedName()));
        }
        // log.info("Step i= " + i);
        // i++;

        if (acTable.getActionByName(NoAction.NO_ACTION_NAME) != null) {
            noActionId =  PiActionId.of(NoAction.NO_ACTION_NAME);
        }
        // log.info("Step i= " + i);
        // i++;

        if (setOutPortAction == null || outPortParam == null) {
            Action fwdAction = acTable.getActionByName(Control.SET_OUT_PORT_ACTION_NAME);
            setOutPortAction = PiActionId.of(fwdAction.getFullyQualifiedName());
            outPortParam = PiActionParamId.of(fwdAction.getParameters().get(0).getName());
        }
        // log.info("Step i= " + i);
        // i++;

        if (sendToControllerAction == null) {
            Action fwdControllerAction = acTable.getActionByName(Control.SEND_TO_CONTROLLER_ACTION_NAME);
            sendToControllerAction = PiActionId.of(fwdControllerAction.getFullyQualifiedName());
        }
        // log.info("Step i= " + i);
        // i++;

        if (packetStatefulProcessing == null) {
            Action statefulProcAction = acTable.getActionByName(Control.STATEFUL_PROC_ACTION_NAME);
            if (statefulProcAction != null) {
                packetStatefulProcessing = PiActionId.of(statefulProcAction.getFullyQualifiedName());
            }
        }
        // log.info("Step i= " + i);
        // i++;

        if (isStatefulParam == null) {
            isStatefulParam = PiActionParamId.of(Control.IS_STATEFUL_FLOW_PARAM_NAME);
        }
        // log.info("Step i= " + i);
        // i++;

        if (stateIndexParam == null) {
            stateIndexParam = PiActionParamId.of(Control.STATE_INDEX_PARAM_NAME);
        }
        // log.info("Step i= " + i);
        // i++;

        if (isDependentFlowParam == null) {
            isDependentFlowParam = PiActionParamId.of(Control.IS_DEPENDENT_PARAM_NAME);
        }
        // log.info("Step i= " + i);
        // i++;

        if (dependencyStateIndexParam == null) {
            dependencyStateIndexParam = PiActionParamId.of(Control.DEPENDENCY_STATE_INDEX_PARAM_NAME);
        }
        // log.info("Step i= " + i);
        // i++;

        if (pcktOutEgress == null) {
            pcktOutEgress = PiPacketMetadataId.of(ControllerHeader.PACKET_OUT_EGRESS_PORT);
        }

        // log.info("Step i= " + i);
        // i++;


        // Action fwdAction = acTable.getActionByName(Control.SET_OUT_PORT_ACTION_NAME);
        // Action fwdControllerAction = acTable.getActionByName(Control.SEND_TO_CONTROLLER_ACTION_NAME);
        // Action statefulProcAction = acTable.getActionByName(Control.STATEFUL_PROC_ACTION_NAME);
        // setOutPortAction = PiActionId.of(fwdAction.getFullyQualifiedName());
        // sendToControllerAction = PiActionId.of(fwdControllerAction.getFullyQualifiedName());
        // packetStatefulProcessing = PiActionId.of(statefulProcAction.getFullyQualifiedName());
        // outPortParam = PiActionParamId.of(fwdAction.getParameters().get(0).getName());
        // isStatefulParam = PiActionParamId.of(Control.IS_STATEFUL_FLOW_PARAM_NAME);
        // stateIndexParam = PiActionParamId.of(Control.STATE_INDEX_PARAM_NAME);
        // isDependentFlowParam = PiActionParamId.of(Control.IS_DEPENDENT_PARAM_NAME);
        // dependencyStateIndexParam = PiActionParamId.of(Control.DEPENDENCY_STATE_INDEX_PARAM_NAME);
        // pcktOutEgress = PiPacketMetadataId.of(ControllerHeader.PACKET_OUT_EGRESS_PORT);
        // log.info("Init Done!!");
    }

    /***
     * We develop the criterion map as per the generated matching fields of the pipeline
     * @param matchFields The matching fields generated by the compilation process
     */
    public static void initFwd(Pipeline pipeline, Logger l) {
        // , List<String> matchFields, String defaultTableFullName, 
        //                         boolean isNoAction, Action fwdAction, Action fwdControllerAction) {
            log = l;
            Table fwdTable = pipeline.getControlBlockByName(BMV2Pipeline.INGRESS_CONTROL_NAME).getTable(Control.L2_FWD_TABLE_NAME);
            
            if (fwdTable == null)
                return;
    
            List<String> matchFields = fwdTable.getKeyEntriesAsStringList();
    
            for(String mf: matchFields) {
                // log.info("Match Field: " + mf);
                if(mf.startsWith(BMV2Pipeline.STD_META_EGRESS_INGRESS_PORT_NAME)) {
                    criterionToPiMatchFieldMap.put(Criterion.Type.IN_PORT, 
                                        PiMatchFieldId.of(BMV2Pipeline.STD_META_EGRESS_INGRESS_PORT_NAME));
                } else {
                    Pattern pattern = Pattern.compile(BMV2Pipeline.PARSED_HEADERS_NAME + "\\.(\\w+)\\.(\\w+)");
                    Matcher matcher = pattern.matcher(mf);
    
                    if(matcher.find()) {
                        Criterion.Type type =  Protocol.getCriterionType(matcher.group(1),  matcher.group(2));
    
                        if(type != null) {
                            // log.info("Type found: " + type);
                            criterionToPiMatchFieldMap.put(type, PiMatchFieldId.of(mf));
                        }
                    }
                }
            }

            if(tableMap.get(1) == null)
                tableMap.put(1, PiTableId.of(fwdTable.getFullyQualifiedName()));

            if (fwdTable.getActionByName(NoAction.NO_ACTION_NAME) != null) {
                noActionId =  PiActionId.of(NoAction.NO_ACTION_NAME);
            }

            if (setOutPortAction == null || outPortParam == null) {
                Action fwdAction = fwdTable.getActionByName(Control.SET_OUT_PORT_ACTION_NAME);
                setOutPortAction = PiActionId.of(fwdAction.getFullyQualifiedName());
                outPortParam = PiActionParamId.of(fwdAction.getParameters().get(0).getName());
            }

            if (sendToControllerAction == null) {
                Action fwdControllerAction = fwdTable.getActionByName(Control.SEND_TO_CONTROLLER_ACTION_NAME);
                sendToControllerAction = PiActionId.of(fwdControllerAction.getFullyQualifiedName());
            }

            if (pcktOutEgress == null) {
                pcktOutEgress = PiPacketMetadataId.of(ControllerHeader.PACKET_OUT_EGRESS_PORT);
            }            
        }

    @Override
    public Optional<PiMatchFieldId> mapCriterionType(Type type) {
        // log.info("Cryterion type is = " + type);
        return Optional.ofNullable(criterionToPiMatchFieldMap.get(type));
    }

    @Override
    public Optional<PiTableId> mapFlowRuleTableId(int flowRuleTableId) {
        // This method is invoked when other request the installation of a FlowRule/Objective
        // without specifying the table. Thus in this case flowRuleTableId = 0;
        return Optional.ofNullable(tableMap.get(flowRuleTableId));
    }

    // @Override
    // public abstract Optional<PiTableId> mapFlowRuleTableId(int flowRuleTableId);

    @Override
    public PiAction mapTreatment(TrafficTreatment treatment, PiTableId piTableId) 
                    throws PiInterpreterException {
                        
        if (piTableId != tableMap.get(0) && piTableId != tableMap.get(1)) {
            throw new PiInterpreterException(
                    "Can map treatments only for the ACL or FWD tables");
        }

        if (treatment.allInstructions().size() == 0) {
            // 0 instructions means "NoAction"
            if (noActionId != null)
                return PiAction.builder().withId(noActionId).build();
            else
                throw new PiInterpreterException("NoAction is not enabled in the pipeline");
        } else if (treatment.allInstructions().size() > 1) {
            // We understand treatments with only 1 instruction.
            throw new PiInterpreterException("Treatment has multiple instructions");
        }

        // boolean containsStatefulInstructions = false;
        // log.info("Processing Treatment!!!!!!!!!!!!!!!!!");
        // Get the first and only instruction.
        Instruction instruction = treatment.allInstructions().get(0);

        if (instruction instanceof ExtendedInstruction) { 
            // log.info("Treatment has stateful component");
            ExtendedInstruction ei = (ExtendedInstruction) instruction;

            if (ei.extendedType() != ExtendedInstruction.ExtendedType.STATEFUL_PROCESSING) {
                throw new PiInterpreterException(format(
                            "Instruction of type '%s' not supported", ei.extendedType()));
            }

            StatefulProcessingInstruction stateInstruction = (StatefulProcessingInstruction) ei;
            Builder statefulAction = PiAction.builder();
            statefulAction.withId(packetStatefulProcessing);

            if (stateInstruction.isKeepState()) {
                statefulAction.withParameter(new PiActionParam(isStatefulParam, copyFrom(1)))
                                .withParameter(new PiActionParam(stateIndexParam, copyFrom(stateInstruction.getStateId())));
            } else {
                statefulAction.withParameter(new PiActionParam(isStatefulParam, copyFrom(0)))
                                .withParameter(new PiActionParam(stateIndexParam, copyFrom(0)));   
            }

            if (stateInstruction.isDependent()) {
                statefulAction.withParameter(new PiActionParam(isDependentFlowParam, copyFrom(1)))
                                .withParameter(new PiActionParam(dependencyStateIndexParam, copyFrom(stateInstruction.getDependencyStateId())));
            } else {
                statefulAction.withParameter(new PiActionParam(isDependentFlowParam, copyFrom(0)))
                                .withParameter(new PiActionParam(dependencyStateIndexParam, copyFrom(0)));
            }

            statefulAction.withParameter(new PiActionParam(
                                        outPortParam, copyFrom(stateInstruction.getOutputPort())));

            return statefulAction.build();

        } else if (instruction.type() == OUTPUT) {
            OutputInstruction outInstruction = (OutputInstruction) instruction;
            PortNumber port = outInstruction.port();

            if (!port.isLogical()) {
                return PiAction.builder()
                        .withId(setOutPortAction)
                        .withParameter(new PiActionParam(
                                outPortParam, copyFrom(port.toLong())))
                        .build();
            } else if (port.equals(CONTROLLER)) {
                return PiAction.builder()
                        .withId(sendToControllerAction)
                        .build();
            } else {
                throw new PiInterpreterException(format(
                        "Output on logical port '%s' not supported", port));
            }

        } else {
            // We can map only instructions of type OUTPUT.
            throw new PiInterpreterException(format(
                    "Instruction of type '%s' not supported", instruction.type()));
        }

        


        // for(Instruction instruction: treatment.allInstructions()) {

        //     if (instruction instanceof ExtendedInstruction) {
        //         ExtendedInstruction ei = (ExtendedInstruction) instruction;
        //         containsStatefulInstructions = true;

        //         log.info("Treatment has stateful component");

        //         if (ei.extendedType() == ExtendedInstruction.ExtendedType.STATE) {
        //             StateIdInstruction sIdInstruction = (StateIdInstruction) ei;
        //             int stateId = sIdInstruction.stateId();

        //             if (stateId == -1) {
        //                 statefulAction.withParameter(new PiActionParam(isStatefulParam, copyFrom(0)))
        //                         .withParameter(new PiActionParam(stateIndexParam, copyFrom(0)));    
        //             } else {
        //                 statefulAction.withParameter(new PiActionParam(isStatefulParam, copyFrom(1)))
        //                         .withParameter(new PiActionParam(stateIndexParam, copyFrom(stateId)));
        //             }
        //         } else { // Dependency Instruction 
        //             DependencyStateIdInstruction dsIdInstuction = (DependencyStateIdInstruction) ei;
        //             int depStateId = dsIdInstuction.dependencyStateId();

        //             if (depStateId == -1) {
        //                 statefulAction.withParameter(new PiActionParam(isDependentFlowParam, copyFrom(0)))
        //                         .withParameter(new PiActionParam(dependencyStateIndexParam, copyFrom(0)));
        //             } else {
        //                 statefulAction.withParameter(new PiActionParam(isDependentFlowParam, copyFrom(1)))
        //                         .withParameter(new PiActionParam(dependencyStateIndexParam, copyFrom(depStateId)));
        //             }                    
        //         }

        //     } else {
        //         if (instruction.type() != OUTPUT) {
        //             // We can map only instructions of type OUTPUT.
        //             throw new PiInterpreterException(format(
        //                     "Instruction of type '%s' not supported", instruction.type()));
        //         }
        
        //         OutputInstruction outInstruction = (OutputInstruction) instruction;
        //         PortNumber port = outInstruction.port();
        
        //         if (!port.isLogical()) {
        //             statefulAction.withParameter(new PiActionParam(
        //                                 outPortParam, copyFrom(port.toLong())));
        //             // return PiAction.builder()
        //             //         .withId(setOutPortAction)
        //             //         .withParameter(new PiActionParam(
        //             //                 outPortParam, copyFrom(port.toLong())))
        //             //         .build();
        //         } else if (port.equals(CONTROLLER)) {
        //             // statefulAction.withId(sendToControllerAction);
        //             return PiAction.builder()
        //                     .withId(sendToControllerAction)
        //                     .build();
        //         } else {
        //             throw new PiInterpreterException(format(
        //                     "Output on logical port '%s' not supported", port));
        //         }
        //     }
        // }

        // if (containsStatefulInstructions) {
        //     statefulAction.withId(packetStatefulProcessing);
        // } else {
        //     statefulAction.withId(setOutPortAction);
        // }


        // return statefulAction.build();

        // Get the first and only instruction.
        // Instruction instruction = treatment.allInstructions().get(0);

        // if (instruction.type() != OUTPUT) {
        //     // We can map only instructions of type OUTPUT.
        //     throw new PiInterpreterException(format(
        //             "Instruction of type '%s' not supported", instruction.type()));
        // }

        // OutputInstruction outInstruction = (OutputInstruction) instruction;
        // PortNumber port = outInstruction.port();

        // if (!port.isLogical()) {
        //     return PiAction.builder()
        //             .withId(setOutPortAction)
        //             .withParameter(new PiActionParam(
        //                     outPortParam, copyFrom(port.toLong())))
        //             .build();
        // } else if (port.equals(CONTROLLER)) {
        //     return PiAction.builder()
        //             .withId(sendToControllerAction)
        //             .build();
        // } else {
        //     throw new PiInterpreterException(format(
        //             "Output on logical port '%s' not supported", port));
        // }
    }

    @Override
    public Collection<PiPacketOperation> mapOutboundPacket(OutboundPacket packet) 
                    throws PiInterpreterException {
        
        TrafficTreatment treatment = packet.treatment();

        // We support only packet-out with OUTPUT instructions.
        if (treatment.allInstructions().size() != 1 &&
                treatment.allInstructions().get(0).type() != OUTPUT) {
            throw new PiInterpreterException(
                    "Treatment not supported: " + treatment.toString());
        }

        Instruction instruction = treatment.allInstructions().get(0);
        PortNumber port = ((OutputInstruction) instruction).port();
        List<PiPacketOperation> piPacketOps = Lists.newArrayList();

        if (!port.isLogical()) {
            piPacketOps.add(createPiPacketOp(packet.data(), port.toLong()));
        } else if (port.equals(FLOOD)) {
            // Since mytunnel.p4 does not support flooding, we create a packet
            // operation for each switch port.
            DeviceService deviceService = handler().get(DeviceService.class);
            DeviceId deviceId = packet.sendThrough();
            for (Port p : deviceService.getPorts(deviceId)) {
                piPacketOps.add(createPiPacketOp(packet.data(), p.number().toLong()));
            }
        } else {
            throw new PiInterpreterException(format(
                    "Output on logical port '%s' not supported", port));
        }

        return piPacketOps;
    }

    @Override
    public InboundPacket mapInboundPacket(PiPacketOperation packetIn, DeviceId deviceId)
            throws PiInterpreterException {

        // We assume that the packet is ethernet, which is fine since mytunnel.p4
        // can deparse only ethernet packets.
        Ethernet ethPkt;
        try {
            ethPkt = Ethernet.deserializer().deserialize(
                    packetIn.data().asArray(), 0, packetIn.data().size());
        } catch (DeserializationException dex) {
            throw new PiInterpreterException(dex.getMessage());
        }

        // Returns the ingress port packet metadata.
        Optional<PiPacketMetadata> packetMetadata = packetIn.metadatas().stream()
                .filter(metadata -> metadata.id().toString().equals(ControllerHeader.PACKET_IN_INGRESS_PORT))
                .findFirst();
        
        if (packetMetadata.isPresent()) {
            short s = packetMetadata.get().value().asReadOnlyBuffer().getShort();
            ConnectPoint receivedFrom = new ConnectPoint(
                    deviceId, PortNumber.portNumber(s));
            return new DefaultInboundPacket(
                    receivedFrom, ethPkt, packetIn.data().asReadOnlyBuffer());
        } else {
            throw new PiInterpreterException(format(
                    "Missing metadata '%s' in packet-in received from '%s': %s",
                    ControllerHeader.PACKET_IN_INGRESS_PORT, deviceId, packetIn));
        }          
    }

    private PiPacketOperation createPiPacketOp(ByteBuffer data, long portNumber)
            throws PiInterpreterException {
        PiPacketMetadata metadata = createPacketMetadata(portNumber);
        return PiPacketOperation.builder()
                .withType(PACKET_OUT)
                .withData(copyFrom(data))
                .withMetadatas(ImmutableList.of(metadata))
                .build();
    }

    private PiPacketMetadata createPacketMetadata(long portNumber)
            throws PiInterpreterException {
        try {
            return PiPacketMetadata.builder()
                    .withId(pcktOutEgress)
                    .withValue(copyFrom(portNumber).fit(BMV2Pipeline.BMV2_PORT_LEN))
                    .build();
        } catch (ImmutableByteSequence.ByteSequenceTrimException e) {
            throw new PiInterpreterException(format(
                    "Port number %d too big, %s", portNumber, e.getMessage()));
        }
    }
}

// /**
//  * InnerPipelineIntepreterHandler
//  */
// class InnerPipelineIntepreterHandler extends PipelineIntepreterHandler {

//     @Override
//     public Optional<PiTableId> mapFlowRuleTableId(int flowRuleTableId) {
//         // This method is invoked when other request the installation of a FlowRule/Objective
//         // without specifying the table. Thus in this case flowRuleTableId = 0;
//         return Optional.ofNullable(tableMap.get(1));
//     }

    
// }
